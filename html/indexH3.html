<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <title>Database Design and Implementation</title>
    <style>
        button {
          background-color: #001a00; /* Dark green background */
          color: #33ff33; /* Bright green text */
          font-family: 'Courier New', monospace;
          font-weight: bold;
          border: 1px solid #33ff33;
          padding: 8px 15px;
          cursor: pointer;
          transition: all 0.3s;
          text-transform: uppercase;
          letter-spacing: 1px;
          display: flex; /* Align icon and text */
          align-items: center;
      }
      button:hover {
          background-color: rgba(51, 255, 51, 0.2);
          color: #ffffff; /* White text on hover */
          box-shadow: 0 0 8px rgba(51, 255, 51, 0.6);
      }
      button:disabled {
          background-color: #05050a; /* Darker background when disabled */
          color: #447744; /* Dimmed green text */
          border-color: #225522; /* Dimmed border */
          cursor: not-allowed;
          opacity: 0.6;
      }
      button .lucide {
          margin-right: 8px; /* Space before text */
      }
        /* General styles - Mainframe inspired but optimized for learning */
        body {
            background-color: #0a0a14;
            color: #b3ffb3;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            text-shadow: 0 0 2px rgba(179, 255, 179, 0.4);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(10, 10, 20, 0.7);
            border: 1px solid #33ff33;
            box-shadow: 0 0 10px rgba(51, 255, 51, 0.3);
        }
        header {
            background-color: #001a00;
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #33ff33;
            margin-bottom: 30px;
        }
        h1 {
            color: #33ff33;
            font-size: 2.2rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        nav {
            background-color: #001a00;
            padding: 10px 0;
            margin-bottom: 30px;
            border-bottom: 1px solid #33ff33;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        nav li {
            margin: 5px 15px; /* Add vertical margin for wrapped items */
        }
        nav a {
            color: #33ff33;
            text-decoration: none;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 3px;
            transition: all 0.3s;
        }
        nav a:hover {
            background-color: rgba(51, 255, 51, 0.2);
            color: #ffffff;
        }
        section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: rgba(0, 26, 0, 0.3);
            border-left: 3px solid #33ff33;
        }
        h2 {
            color: #00ff99;
            border-bottom: 1px solid #00ff99;
            padding-bottom: 10px;
            font-size: 1.8rem;
        }
        h3 {
            color: #00ffcc;
            font-size: 1.4rem;
            margin-top: 25px;
        }
        h4 { /* Style for h4 */
            color: #00e6b8; /* Slightly different color */
            font-size: 1.2rem;
            margin-top: 20px;
            text-decoration: underline;
        }
        p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        .code-block {
            background-color: #000000;
            border: 1px solid #33ff33;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            color: #33ff33;
            white-space: pre; /* Preserve whitespace and line breaks */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: rgba(0, 0, 0, 0.5);
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #33ff33;
        }
        th {
            background-color: #001a00;
            color: #00ff99;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        tr:hover {
            background-color: rgba(51, 255, 51, 0.1);
        }
        ul, ol {
            padding-left: 25px;
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        .note {
            background-color: rgba(0, 26, 51, 0.5);
            border-left: 4px solid #3399ff;
            padding: 15px;
            margin: 20px 0;
            color: #99ccff;
        }
        .important {
            background-color: rgba(51, 0, 0, 0.5);
            border-left: 4px solid #ff3333;
            padding: 15px;
            margin: 20px 0;
            color: #ffb3b3;
        }
        .terminal {
            background-color: #000000;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            color: #33ff33;
            border: 1px solid #33ff33;
            position: relative;
        }
        .terminal::before {
            content: "z/OS >";
            color: #00ff99;
            font-weight: bold;
            margin-right: 10px;
        }
        .diagram {
            background-color: #000000;
            border: 1px solid #33ff33;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-style: italic;
        }
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #33ff33;
            font-size: 0.9rem;
            color: #66ff66;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            nav ul {
                flex-direction: column;
                align-items: center;
            }
            nav li {
                margin: 5px 0;
            }
            h1 {
                font-size: 1.8rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            h3 {
                font-size: 1.2rem;
            }
            h4 {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Database Design and Implementation</h1>
            <button id="back-to-quiz-btn">
                <span class="lucide">&#xe3a7;</span> Back To Mainpage
            </button>
        </header>

        <nav>
             <ul>
                 <li><a href="#principles">Principles</a></li>
                 <li><a href="#objects">Objects</a></li>
                 <li><a href="#integrity">Integrity</a></li>
                 <li><a href="#advanced">Advanced</a></li>
                 <li><a href="#practices">Practices</a></li>
                 <li><a href="#conclusion">Conclusion</a></li>
             </ul>
         </nav>

        <section id="principles">
            <h2>Principles of Efficient Database Schema Design</h2>

            <h3>Requirements Analysis and Conceptual Design</h3>
            <p>Database design begins with a thorough understanding of business requirements. This initial phase is critical as it establishes the foundation for all subsequent design decisions. The process includes:</p>
            <h4>Business Requirements Gathering:</h4>
            <ul>
                <li>Interviewing stakeholders to identify:</li>
                <ul>
                    <li>Data entities and their relationships</li>
                    <li>Business rules and constraints</li>
                    <li>Current and future transaction volumes</li>
                    <li>Performance expectations</li>
                    <li>Security and compliance requirements</li>
                </ul>
            </ul>
            <h4>Entity-Relationship Modeling:</h4>
            <ul>
                <li>Developing a conceptual data model that represents:</li>
                <ul>
                    <li>Entities (business objects)</li>
                    <li>Attributes (properties of those objects)</li>
                    <li>Relationships (connections between entities)</li>
                    <li>Cardinality (one-to-one, one-to-many, many-to-many)</li>
                    <li>Optionality (mandatory or optional relationships)</li>
                </ul>
            </ul>
            <h4>Data Flow Analysis:</h4>
            <ul>
                <li>Understanding how data moves through the organization:</li>
                <ul>
                    <li>Source systems and data origins</li>
                    <li>Processing requirements</li>
                    <li>Reporting and analytics needs</li>
                    <li>Data retention policies</li>
                    <li>Archival requirements</li>
                </ul>
            </ul>
            <p>The conceptual design phase should be platform-independent, focusing on business concepts rather than DB2-specific implementation details.</p>

            <h3>Logical Database Design</h3>
            <p>Logical database design translates the conceptual model into a structure closer to implementation while remaining DBMS-independent:</p>
            <h4>Entity Mapping:</h4>
            <ul>
                <li>Converting entities to tables and attributes to columns.</li>
            </ul>
            <h4>Primary Key Selection:</h4>
            <ul>
                <li>Identifying columns that uniquely identify each row, considering:</li>
                <ul>
                    <li>Natural keys (business identifiers)</li>
                    <li>Surrogate keys (system-generated identifiers)</li>
                    <li>Composite keys (multiple columns)</li>
                </ul>
            </ul>
            <h4>Foreign Key Identification:</h4>
            <ul>
                <li>Establishing relationships between tables through shared keys.</li>
            </ul>
            <h4>Normalization:</h4>
            <ul>
                <li>Applying normal forms to reduce redundancy:</li>
                <ul>
                    <li>First Normal Form (1NF): Eliminating repeating groups</li>
                    <li>Second Normal Form (2NF): Removing partial dependencies</li>
                    <li>Third Normal Form (3NF): Eliminating transitive dependencies</li>
                    <li>Boyce-Codd Normal Form (BCNF): Addressing anomalies not fixed by 3NF</li>
                    <li>Fourth Normal Form (4NF): Handling multi-valued dependencies</li>
                    <li>Fifth Normal Form (5NF): Addressing join dependencies</li>
                </ul>
            </ul>
            <h4>Denormalization Considerations:</h4>
            <ul>
                <li>Identifying where controlled redundancy might improve performance:</li>
                <ul>
                    <li>Frequently joined tables</li>
                    <li>Common aggregation calculations</li>
                    <li>Read-intensive workloads</li>
                </ul>
            </ul>
            <h4>Data Integrity Rules:</h4>
            <ul>
                <li>Defining constraints:</li>
                <ul>
                    <li>Domain constraints (data types, valid values)</li>
                    <li>Entity integrity constraints (primary keys)</li>
                    <li>Referential integrity constraints (foreign keys)</li>
                    <li>Business-specific constraints</li>
                </ul>
            </ul>

            <h3>Physical Database Design for DB2</h3>
            <p>Physical design optimizes the logical model for DB2's architecture and the specific workload:</p>
            <h4>Tablespace Strategy:</h4>
            <ul>
                <li>Selecting appropriate tablespace types (simple, segmented, partitioned, universal)</li>
                <li>Determining page sizes (4K, 8K, 16K, 32K)</li>
                <li>Planning for growth (PRIQTY and SECQTY)</li>
                <li>Deciding on compression options</li>
            </ul>
            <h4>Indexing Strategy:</h4>
            <ul>
                <li>Identifying columns for indexing based on access patterns</li>
                <li>Choosing appropriate index types (unique, non-unique, clustering)</li>
                <li>Considering partitioned indexes for large tables</li>
                <li>Planning for index maintenance overhead</li>
            </ul>
            <h4>Partitioning Strategy:</h4>
            <ul>
                <li>Evaluating table partitioning needs</li>
                <li>Selecting partition keys based on workload</li>
                <li>Aligning with business processes (e.g., time-based partitioning)</li>
                <li>Planning for partition maintenance</li>
            </ul>
            <h4>Storage Management:</h4>
            <ul>
                <li>STOGROUP selection and volume distribution</li>
                <li>Dataset placement for I/O balance</li>
                <li>Buffer pool assignments</li>
                <li>SMS integration considerations</li>
            </ul>
            <h4>Performance Considerations:</h4>
            <ul>
                <li>Clustering sequence for physical data organization</li>
                <li>Free space parameters (PCTFREE, FREEPAGE)</li>
                <li>Prefetch optimization</li>
                <li>Impact of locking strategies</li>
            </ul>

            <h3>Workload-Based Optimization</h3>
            <p>Different workloads require different design approaches:</p>
            <h4>OLTP Optimization:</h4>
            <ul>
                <li>Highly normalized design</li>
                <li>Strategic denormalization for performance</li>
                <li>Focused indexes on transaction paths</li>
                <li>Smaller page sizes</li>
                <li>Fine-grained locking</li>
            </ul>
            <h4>Data Warehouse Optimization:</h4>
            <ul>
                <li>Star or snowflake schema designs</li>
                <li>Dimensional modeling techniques</li>
                <li>Aggregate tables for reporting</li>
                <li>Larger page sizes</li>
                <li>Bulk data loading considerations</li>
            </ul>
            <h4>Mixed Workload Strategies:</h4>
            <ul>
                <li>Isolation of OLTP and analytical workloads</li>
                <li>Time-of-day considerations</li>
                <li>Workload-specific buffer pools</li>
                <li>Application-level query routing</li>
            </ul>
            <h4>Temporal Data Management:</h4>
            <ul>
                <li>Effective dating strategies</li>
                <li>History tracking approaches</li>
                <li>System time versus business time</li>
                <li>Purge and archive strategies</li>
            </ul>
        </section>

        <section id="objects">
            <h2>Creating and Managing Database Objects</h2>

            <h3>Database Object Hierarchy</h3>
            <p>DB2 organizes objects in a hierarchical structure:</p>
            <h4>Subsystem:</h4>
            <ul>
                <li>The DB2 instance itself</li>
                <li>Contains one or more databases</li>
                <li>Managed by system administrators</li>
            </ul>
            <h4>Database:</h4>
            <ul>
                <li>A collection of related objects</li>
                <li>Container for tables, views, and other objects</li>
                <li>Provides namespace separation</li>
                <li>Facilitates administrative control</li>
                <li>Created with the CREATE DATABASE statement</li>
            </ul>
            <h4>Schema:</h4>
            <ul>
                <li>Logical grouping of objects within a database</li>
                <li>Often aligned with application or owner</li>
                <li>Provides additional namespace qualification</li>
                <li>Controls security boundaries</li>
                <li>Created implicitly through object creation</li>
            </ul>
            <h4>Tablespace:</h4>
            <ul>
                <li>Physical storage for tables</li>
                <li>Maps logical tables to physical storage</li>
                <li>Multiple types available for different needs</li>
                <li>Created with the CREATE TABLESPACE statement</li>
            </ul>
            <h4>Table:</h4>
            <ul>
                <li>Structure for storing data</li>
                <li>Foundation of relational database</li>
                <li>Contains rows (records) and columns (fields)</li>
                <li>Created with the CREATE TABLE statement</li>
            </ul>
            <h4>Index:</h4>
            <ul>
                <li>Access path to improve retrieval</li>
                <li>Optimizes query performance</li>
                <li>Multiple types for different access patterns</li>
                <li>Created with the CREATE INDEX statement</li>
            </ul>
            <h4>View:</h4>
            <ul>
                <li>Virtual table derived from other tables</li>
                <li>Provides logical data abstraction</li>
                <li>Can simplify complex queries</li>
                <li>Enables data security control</li>
                <li>Created with the CREATE VIEW statement</li>
            </ul>

            <h3>Table Creation and Management</h3>
            <p>Tables are the primary storage structures in DB2:</p>
            <h4>Table Creation Syntax:</h4>
<pre class="code-block">
CREATE TABLE schema.table_name (
    column1 datatype constraints,
    column2 datatype constraints,
    ...
    PRIMARY KEY (column),
    FOREIGN KEY (column) REFERENCES parent_table(column),
    CHECK (condition)
 ) IN database.tablespace
   AUDIT NONE|CHANGES|ALL
   DATA CAPTURE NONE|CHANGES
   CCSID ASCII|EBCDIC|UNICODE;
</pre>
            <h4>Column Definition Considerations:</h4>
            <ul>
                <li>Data types selection based on content and usage</li>
                <li>CHAR vs. VARCHAR tradeoffs</li>
                <li>Numeric precision and scale</li>
                <li>Date and time formats</li>
                <li>LOB and XML handling</li>
                <li>Default values</li>
                <li>NULL or NOT NULL constraints</li>
            </ul>
            <h4>Table Partitioning Options:</h4>
            <ul>
                <li>Range partitioning based on column values</li>
                <li>Growth management</li>
                <li>Data lifecycle planning</li>
                <li>Partition independence for maintenance</li>
            </ul>
            <h4>Auditing and Tracking Options:</h4>
            <ul>
                <li>AUDIT clause for security monitoring</li>
                <li>DATA CAPTURE for replication or audit trails</li>
                <li>CCSID for character encoding</li>
            </ul>
            <h4>Table Alteration:</h4>
            <ul>
                <li>Adding, modifying, or dropping columns</li>
                <li>Adding or removing constraints</li>
                <li>Activating row permissions or column masks</li>
                <li>Reorganizing physical storage</li>
                <li>Rotating partitions</li>
            </ul>
            <h4>Table Management Commands:</h4>
            <ul>
                <li>ALTER TABLE for structure changes</li>
                <li>COMMENT ON for documentation</li>
                <li>LABEL ON for providing column labels</li>
                <li>RENAME TABLE for changing names</li>
                <li>DROP TABLE for removal</li>
            </ul>

            <h3>Index Design and Implementation</h3>
            <p>Indexes are critical for performance optimization:</p>
            <h4>Index Types:</h4>
            <ul>
                <li>Unique vs. Non-unique</li>
                <li>Clustering vs. Non-clustering</li>
                <li>Partitioned vs. Non-partitioned</li>
                <li>Padded vs. Non-padded</li>
                <li>Type 1 vs. Type 2 (older versions)</li>
                <li>Expression-based indexes</li>
            </ul>
            <h4>Index Creation Syntax:</h4>
<pre class="code-block">
CREATE [UNIQUE] INDEX schema.index_name
   ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)
   [INCLUDE (column3, column4, ...)]
   [CLUSTER]
   [PADDED|NOT PADDED]
   [USING VCAT catalog_name | STOGROUP stogroup_name]
   [BUFFERPOOL bp_name]
   [CLOSE YES|NO]
   [PIECESIZE integer [K|M|G]];
</pre>
            <h4>Index Column Selection Strategies:</h4>
            <ul>
                <li>High-cardinality columns</li>
                <li>Commonly used WHERE clause columns</li>
                <li>JOIN columns</li>
                <li>ORDER BY and GROUP BY columns</li>
                <li>Foreign key columns</li>
            </ul>
            <h4>Clustering Considerations:</h4>
            <ul>
                <li>Only one clustering index per table</li>
                <li>Determines physical data organization</li>
                <li>Critical for range scans</li>
                <li>Impacts load and reorganization operations</li>
            </ul>
            <h4>Index Management:</h4>
            <ul>
                <li>Monitoring index usage</li>
                <li>Dropping unused indexes</li>
                <li>Rebuilding for efficiency</li>
                <li>Managing free space</li>
                <li>Compression options</li>
            </ul>
            <h4>Index Design Best Practices:</h4>
            <ul>
                <li>Minimize index width</li>
                <li>Balance number of indexes against maintenance overhead</li>
                <li>Consider including columns for index-only access</li>
                <li>Evaluate partitioning alignment with table partitions</li>
                <li>Prioritize indexes based on workload characteristics</li>
            </ul>

            <h3>View Creation and Usage</h3>
            <p>Views provide logical abstractions of underlying tables:</p>
            <h4>View Creation Syntax:</h4>
<pre class="code-block">
CREATE VIEW schema.view_name [(column_names)]
   AS SELECT columns
   FROM tables
   WHERE conditions
   WITH [CASCADED|LOCAL] CHECK OPTION;
</pre>
            <h4>View Types and Characteristics:</h4>
            <ul>
                <li>Simple views (single table)</li>
                <li>Complex views (joins, functions, expressions)</li>
                <li>Updateable vs. read-only views</li>
                <li>WITH CHECK OPTION enforcement</li>
            </ul>
            <h4>View Usage Scenarios:</h4>
            <ul>
                <li>Simplifying complex queries</li>
                <li>Implementing row and column access control</li>
                <li>Providing logical data independence</li>
                <li>Supporting legacy applications</li>
                <li>Presenting denormalized views of normalized data</li>
            </ul>
            <h4>View Management:</h4>
            <ul>
                <li>Altering view definitions</li>
                <li>Dropping dependent views</li>
                <li>Managing authorizations</li>
                <li>Checking view status with catalog queries</li>
            </ul>
            <h4>View Performance Considerations:</h4>
            <ul>
                <li>Materialized query tables (MQTs) for expensive views</li>
                <li>View merge optimization</li>
                <li>View resolution process</li>
                <li>Impact on access paths</li>
            </ul>

            <h3>Other Database Objects</h3>
            <p>Beyond tables, indexes, and views, DB2 supports several specialized objects:</p>
            <h4>Materialized Query Tables (MQTs):</h4>
            <ul>
                <li>Physical tables containing pre-computed query results</li>
                <li>Refresh options (immediate or deferred)</li>
                <li>Query rewrite capabilities</li>
                <li>Maintenance considerations</li>
            </ul>
            <h4>Sequences:</h4>
            <ul>
                <li>Generated unique values</li>
                <li>Configured with increment, min/max values, and cycling options</li>
                <li>Used for surrogate key generation</li>
                <li>Created with CREATE SEQUENCE</li>
            </ul>
            <h4>Aliases:</h4>
            <ul>
                <li>Alternative names for tables or views</li>
                <li>Simplify access across databases</li>
                <li>Support for unqualified references</li>
                <li>Created with CREATE ALIAS</li>
            </ul>
            <h4>Synonyms (legacy):</h4>
            <ul>
                <li>Similar to aliases but with limitations</li>
                <li>Maintained for backward compatibility</li>
                <li>Created with CREATE SYNONYM</li>
            </ul>
            <h4>Global Temporary Tables:</h4>
            <ul>
                <li>Session-specific data storage</li>
                <li>Defined once, used by multiple sessions</li>
                <li>No logging overhead</li>
                <li>Created with DECLARE GLOBAL TEMPORARY TABLE</li>
            </ul>
            <h4>Declared Temporary Tables:</h4>
            <ul>
                <li>Application process-specific tables</li>
                <li>Implicitly created and dropped</li>
                <li>Used for temporary result sets</li>
                <li>Declared with DECLARE TEMPORARY TABLE</li>
            </ul>
            <h4>Triggers:</h4>
            <ul>
                <li>Procedural logic executed on data changes</li>
                <li>BEFORE, AFTER, or INSTEAD OF events</li>
                <li>Row or statement level activation</li>
                <li>Created with CREATE TRIGGER</li>
            </ul>
            <h4>User-Defined Types:</h4>
            <ul>
                <li>Custom data types</li>
                <li>Distinct types for strong typing</li>
                <li>Structured types for complex data</li>
                <li>Created with CREATE TYPE</li>
            </ul>
        </section>

        <section id="integrity">
            <h2>Implementing Referential Integrity</h2>

            <h3>Referential Integrity Concepts</h3>
            <p>Referential integrity ensures that relationships between tables remain consistent:</p>
            <h4>Key Components:</h4>
            <ul>
                <li>Parent table (referenced table)</li>
                <li>Child table (referencing table)</li>
                <li>Foreign key (referencing columns)</li>
                <li>Primary or unique key (referenced columns)</li>
                <li>Delete rules (CASCADE, SET NULL, RESTRICT, NO ACTION)</li>
                <li>Insert rules (matching values required)</li>
                <li>Update rules (CASCADE, RESTRICT, NO ACTION)</li>
            </ul>
            <h4>Integrity States:</h4>
            <ul>
                <li>Complete referential integrity (all references valid)</li>
                <li>Partial referential integrity (some checking deferred)</li>
                <li>No referential integrity (checking disabled)</li>
            </ul>
            <h4>Implementation Approaches:</h4>
            <ul>
                <li>DB2 declarative referential integrity (DRI)</li>
                <li>Application-enforced referential integrity</li>
                <li>Trigger-based referential integrity</li>
                <li>Combined approaches</li>
            </ul>

            <h3>Declarative Referential Integrity</h3>
            <p>DRI is implemented through DDL statements:</p>
            <h4>Foreign Key Definition:</h4>
<pre class="code-block">
CREATE TABLE child_table (
    ...
    FOREIGN KEY (fk_column1, fk_column2)
    REFERENCES parent_table (pk_column1, pk_column2)
    ON DELETE CASCADE|SET NULL|RESTRICT|NO ACTION
    ON UPDATE RESTRICT|NO ACTION
    ENFORCED|NOT ENFORCED
    ENABLE QUERY OPTIMIZATION
 );
</pre>
            <h4>Delete Rules:</h4>
            <ul>
                <li>CASCADE: Delete child rows when parent is deleted</li>
                <li>SET NULL: Set foreign key to NULL when parent is deleted</li>
                <li>RESTRICT: Prevent deletion of parent if child rows exist</li>
                <li>NO ACTION: Similar to RESTRICT but checked later in transaction</li>
            </ul>
            <h4>Update Rules:</h4>
            <ul>
                <li>RESTRICT: Prevent updates to parent key if child rows reference it</li>
                <li>NO ACTION: Similar to RESTRICT but checked later in transaction</li>
                <li>CASCADE: Not directly supported in DB2 (requires triggers)</li>
            </ul>
            <h4>Implementation Considerations:</h4>
            <ul>
                <li>Impact on performance (insert, update, delete)</li>
                <li>Locking implications</li>
                <li>Activation sequence for multiple relationships</li>
                <li>Circular or complex relationship handling</li>
            </ul>
            <h4>Constraints on Foreign Keys:</h4>
            <ul>
                <li>Must match parent key in number and compatible data types</li>
                <li>NULL handling in partially NULL foreign keys</li>
                <li>Index requirements</li>
            </ul>

            <h3>Trigger-Based Referential Integrity</h3>
            <p>When declarative RI is insufficient, triggers provide an alternative:</p>
            <h4>Trigger Approach:</h4>
            <ul>
                <li>BEFORE or AFTER triggers on parent and child tables</li>
                <li>Logic to enforce relationship rules</li>
                <li>Custom error handling</li>
                <li>Complex business rules integration</li>
            </ul>
            <h4>Implementing Update CASCADE with Triggers:</h4>
<pre class="code-block">
CREATE TRIGGER parent_update
 AFTER UPDATE OF pk_column ON parent_table
 REFERENCING OLD AS o NEW AS n
 FOR EACH ROW MODE DB2SQL
 BEGIN ATOMIC
   UPDATE child_table
   SET fk_column = n.pk_column
   WHERE fk_column = o.pk_column;
 END;
</pre>
            <h4>Custom Referential Actions:</h4>
            <ul>
                <li>Conditional cascading based on data values</li>
                <li>Logging referential actions to audit tables</li>
                <li>Implementing business-specific behaviors</li>
                <li>Handling multiple relationship paths</li>
            </ul>
            <h4>Performance Considerations:</h4>
            <ul>
                <li>Overhead compared to declarative RI</li>
                <li>Transaction isolation implications</li>
                <li>Error handling complexity</li>
                <li>Maintenance challenges</li>
            </ul>

            <h3>Referential Constraint Management</h3>
            <p>Managing referential integrity over time requires specific techniques:</p>
            <h4>Adding Constraints to Existing Tables:</h4>
            <ul>
                <li>Verifying data compliance before adding constraints</li>
                <li>CHECK DATA utility for validation</li>
                <li>Handling existing violations</li>
                <li>Incremental implementation strategies</li>
            </ul>
            <h4>Temporarily Disabling Constraints:</h4>
            <ul>
                <li>Using NOT ENFORCED option</li>
                <li>SET INTEGRITY options</li>
                <li>Impact on query optimization</li>
                <li>Re-enabling and verification</li>
            </ul>
            <h4>Identifying and Resolving Violations:</h4>
            <ul>
                <li>CHECK DATA utility</li>
                <li>REPORT option to identify violations</li>
                <li>EXCEPTION tables for capturing violations</li>
                <li>Correction strategies</li>
            </ul>
            <h4>Monitoring Referential Integrity:</h4>
            <ul>
                <li>Catalog queries for constraint definitions</li>
                <li>Performance monitoring</li>
                <li>Lock contention analysis</li>
                <li>Identifying constraint-related issues</li>
            </ul>
            <h4>Referential Constraint Cycles:</h4>
            <ul>
                <li>Identifying and managing circular references</li>
                <li>INSERT, UPDATE, and DELETE ordering</li>
                <li>Transaction design implications</li>
                <li>Breaking cycles for maintenance</li>
            </ul>

            <h3>Referential Integrity Best Practices</h3>
            <p>Decades of DB2 implementation experience has established key best practices:</p>
            <h4>Design Phase:</h4>
            <ul>
                <li>Fully document all relationships</li>
                <li>Consider performance implications early</li>
                <li>Balance integrity and performance requirements</li>
                <li>Evaluate alternatives for complex relationships</li>
            </ul>
            <h4>Implementation Phase:</h4>
            <ul>
                <li>Create parent tables before child tables</li>
                <li>Load parent data before child data</li>
                <li>Create indexes on foreign keys</li>
                <li>Test constraint behavior thoroughly</li>
            </ul>
            <h4>Operational Phase:</h4>
            <ul>
                <li>Monitor constraint-related performance</li>
                <li>Coordinate maintenance activities</li>
                <li>Consider integrity implications of recoveries</li>
                <li>Manage constraints during schema evolution</li>
            </ul>
            <h4>Common Pitfalls:</h4>
            <ul>
                <li>Excessive cascading delete chains</li>
                <li>Lock escalation during referential operations</li>
                <li>Overlooking index requirements</li>
                <li>Inconsistent NULL handling</li>
            </ul>
        </section>

        <section id="advanced">
            <h2>Advanced Implementation Techniques</h2>

            <h3>Partitioning Strategies</h3>
            <p>Table partitioning divides large tables into smaller, more manageable pieces:</p>
            <h4>Range Partitioning:</h4>
            <ul>
                <li>Division based on column value ranges</li>
                <li>Typically date-based or numeric ranges</li>
                <li>Supports efficient partition elimination</li>
                <li>Enables partition-level operations</li>
            </ul>
            <h4>Partition-By-Growth:</h4>
            <ul>
                <li>Automatic creation of new partitions as table grows</li>
                <li>Simplifies capacity management</li>
                <li>Reduces need for manual intervention</li>
            </ul>
            <h4>Partition Implementation:</h4>
<pre class="code-block">
CREATE TABLE sales (
    sale_date DATE NOT NULL,
    product_id INTEGER NOT NULL,
    amount DECIMAL(15,2),
    ...
 ) PARTITION BY RANGE(sale_date) (
    PARTITION 1 ENDING AT ('2023-01-31'),
    PARTITION 2 ENDING AT ('2023-02-28'),
    ...
    PARTITION 12 ENDING AT ('2023-12-31')
 );
</pre>
            <h4>Partition Management:</h4>
            <ul>
                <li>Adding new partitions with ALTER TABLE</li>
                <li>Rotating partitions for rolling window scenarios</li>
                <li>Detaching and attaching partitions</li>
                <li>Reorganizing individual partitions</li>
            </ul>
            <h4>Partitioned Indexes:</h4>
            <ul>
                <li>Partitioning index aligned with table partitioning</li>
                <li>Non-partitioning indexes across all partitions</li>
                <li>Data-partitioned secondary indexes (DPSI)</li>
                <li>Choosing appropriate indexing strategy</li>
            </ul>

            <h3>Constraints and Validation</h3>
            <p>DB2 provides multiple constraint types to ensure data integrity:</p>
            <h4>Primary Key Constraints:</h4>
            <ul>
                <li>Ensuring uniqueness and non-nullability</li>
                <li>Implicitly creating unique indexes</li>
                <li>Impact on insertion and update performance</li>
                <li>Considerations for clustered organization</li>
            </ul>
            <h4>Unique Constraints:</h4>
            <ul>
                <li>Ensuring value uniqueness</li>
                <li>Allowing NULL values (unlike primary keys)</li>
                <li>Multiple unique constraints per table</li>
                <li>Implicit index creation</li>
            </ul>
            <h4>Check Constraints:</h4>
            <ul>
                <li>Validating column values against conditions</li>
                <li>Simple validation rules</li>
                <li>Complex expressions and functions</li>
                <li>Performance implications</li>
            </ul>
            <h4>Default Values:</h4>
            <ul>
                <li>Constant values</li>
                <li>Special registers (CURRENT DATE, etc.)</li>
                <li>Session variables</li>
                <li>DEFAULT with NULL</li>
            </ul>
            <h4>Identity Columns:</h4>
            <ul>
                <li>Auto-generated sequential values</li>
                <li>Configuration options (START, INCREMENT, CACHE)</li>
                <li>RESTART capabilities</li>
                <li>Performance considerations</li>
            </ul>
            <h4>Row and Column Access Control:</h4>
            <ul>
                <li>Fine-grained security at data level</li>
                <li>Row permissions for horizontal filtering</li>
                <li>Column masks for vertical filtering</li>
                <li>Integration with application security</li>
            </ul>

            <h3>Schema Evolution Techniques</h3>
            <p>Changing database structures in production environments requires careful planning:</p>
            <h4>Online Schema Change Approaches:</h4>
            <ul>
                <li>ALTER TABLE capabilities and limitations</li>
                <li>REORG with SHRLEVEL CHANGE</li>
                <li>Using versioning for zero-downtime changes</li>
                <li>Managing dependent objects</li>
            </ul>
            <h4>Table Replacement Strategies:</h4>
            <ul>
                <li>CREATE new table with desired structure</li>
                <li>Load or INSERT data with transformations</li>
                <li>Swap tables with minimal downtime</li>
                <li>Managing authorizations and dependencies</li>
            </ul>
            <h4>Index Evolution:</h4>
            <ul>
                <li>Adding indexes online</li>
                <li>Rebuilding indexes for efficiency</li>
                <li>Redefining indexes with minimal impact</li>
                <li>Managing free space during index evolution</li>
            </ul>
            <h4>View-Based Abstraction:</h4>
            <ul>
                <li>Providing logical stability through views</li>
                <li>Changing underlying structures transparently</li>
                <li>Managing view dependencies</li>
                <li>Performance implications of view layers</li>
            </ul>
            <h4>Handling Legacy Applications:</h4>
            <ul>
                <li>Maintaining backward compatibility</li>
                <li>Using triggers for transparent data mapping</li>
                <li>Synonym and alias strategies</li>
                <li>Application version management</li>
            </ul>

            <h3>Performance-Oriented Implementation</h3>
            <p>Database design must balance correctness with performance:</p>
            <h4>I/O Optimization Techniques:</h4>
            <ul>
                <li>Clustering for sequential access</li>
                <li>Page size selection</li>
                <li>FREEPAGE and PCTFREE settings</li>
                <li>MEMBER CLUSTER considerations</li>
            </ul>
            <h4>Memory Optimization:</h4>
            <ul>
                <li>Buffer pool assignments</li>
                <li>KEEPDYNAMIC behavior</li>
                <li>EDM pool management</li>
                <li>Sort pool sizing</li>
            </ul>
            <h4>Concurrency Strategies:</h4>
            <ul>
                <li>LOCKSIZE options (ANY, TABLE, PAGE, ROW)</li>
                <li>ISOLATION levels (CS, RS, RR, UR)</li>
                <li>MAXROWS limitation for query results</li>
                <li>RELEASE options (COMMIT, DEALLOCATE)</li>
            </ul>
            <h4>Utility Performance:</h4>
            <ul>
                <li>SORTKEYS parameter for LOAD</li>
                <li>Parallelism options</li>
                <li>REORG with SHRLEVEL</li>
                <li>RUNSTATS frequency and detail</li>
            </ul>
            <h4>Monitoring and Tuning:</h4>
            <ul>
                <li>Using EXPLAIN for access path analysis</li>
                <li>Catalog statistics for design validation</li>
                <li>Identifying hot spots and bottlenecks</li>
                <li>Incremental design improvements</li>
            </ul>

            <h3>Temporal Data Implementation</h3>
            <p>DB2 provides built-in support for time-based data:</p>
            <h4>System Time (Transaction Time):</h4>
            <ul>
                <li>Automatic tracking of when data changes</li>
                <li>History tables for maintaining previous states</li>
                <li>Transparency for applications</li>
                <li>Point-in-time queries</li>
            </ul>
            <h4>Business Time (Valid Time):</h4>
            <ul>
                <li>Application-controlled effective dating</li>
                <li>Period definition with start/end columns</li>
                <li>Business time temporal queries</li>
                <li>Period constraints for avoiding overlaps</li>
            </ul>
            <h4>Bi-Temporal Tables:</h4>
            <ul>
                <li>Combined system and business time</li>
                <li>Complete historical and time-state representation</li>
                <li>Complex temporal query capabilities</li>
                <li>Compliance and auditing support</li>
            </ul>
            <h4>Implementation Syntax:</h4>
<pre class="code-block">
CREATE TABLE employee (
    emp_id INTEGER NOT NULL,
    name VARCHAR(100),
    department VARCHAR(30),
    salary DECIMAL(10,2),
    sys_start TIMESTAMP(12) NOT NULL GENERATED ALWAYS AS ROW BEGIN,
    sys_end TIMESTAMP(12) NOT NULL GENERATED ALWAYS AS ROW END,
    trans_id TIMESTAMP(12) GENERATED ALWAYS AS TRANSACTION START ID,
    PERIOD SYSTEM_TIME (sys_start, sys_end)
 ) WITH SYSTEM VERSIONING USE HISTORY TABLE employee_history;
</pre>
            <h4>Temporal Table Management:</h4>
            <ul>
                <li>Enabling versioning on existing tables</li>
                <li>Managing history table space</li>
                <li>Archiving historical data</li>
                <li>Recovery considerations for temporal tables</li>
            </ul>
        </section>

        <section id="practices">
            <h2>Implementation Best Practices</h2>

            <h3>Documentation Standards</h3>
            <p>Comprehensive documentation is essential for long-term database sustainability:</p>
            <h4>Schema Documentation:</h4>
            <ul>
                <li>Entity-relationship diagrams</li>
                <li>Table and column descriptions</li>
                <li>Constraint documentation</li>
                <li>Indexing strategies</li>
                <li>Partitioning schemes</li>
            </ul>
            <h4>Naming Conventions:</h4>
            <ul>
                <li>Consistent table, column, and constraint naming</li>
                <li>Schema organization standards</li>
                <li>Object qualification guidelines</li>
                <li>Temporary object conventions</li>
            </ul>
            <h4>Data Dictionary Management:</h4>
            <ul>
                <li>Using COMMENT ON for metadata</li>
                <li>Maintaining additional metadata repositories</li>
                <li>Documentation version control</li>
                <li>Automated documentation generation</li>
            </ul>
            <h4>Change Management Documentation:</h4>
            <ul>
                <li>Schema modification history</li>
                <li>Rationale for design decisions</li>
                <li>Impact analysis documentation</li>
                <li>Rollback procedures</li>
            </ul>

            <h3>Quality Assurance Techniques</h3>
            <p>Ensuring database design quality requires systematic validation:</p>
            <h4>Design Reviews:</h4>
            <ul>
                <li>Normalization verification</li>
                <li>Performance prediction</li>
                <li>Security assessment</li>
                <li>Compliance validation</li>
                <li>Peer review processes</li>
            </ul>
            <h4>Testing Strategies:</h4>
            <ul>
                <li>Unit testing for constraints and triggers</li>
                <li>Performance testing under representative load</li>
                <li>Recovery testing</li>
                <li>Concurrency and locking tests</li>
                <li>Edge case testing</li>
            </ul>
            <h4>Database Verification:</h4>
            <ul>
                <li>CHECK DATA for integrity validation</li>
                <li>RUNSTATS for statistical verification</li>
                <li>EXPLAIN for access path validation</li>
                <li>DSN1COPY with CHECK for physical validation</li>
            </ul>
            <h4>Continuous Improvement:</h4>
            <ul>
                <li>Monitoring for design-related issues</li>
                <li>Periodic design reassessment</li>
                <li>Incremental optimization</li>
                <li>Technical debt management</li>
            </ul>

            <h3>Implementation Planning</h3>
            <p>Successful implementation requires careful planning:</p>
            <h4>Implementation Sequencing:</h4>
            <ul>
                <li>Schema creation order</li>
                <li>Constraint activation timing</li>
                <li>Data population strategy</li>
                <li>Application cutover planning</li>
            </ul>
            <h4>Resource Requirements:</h4>
            <ul>
                <li>Storage needs (initial and growth)</li>
                <li>Memory requirements (buffer pools, etc.)</li>
                <li>Processing capacity (CPU, zIIP)</li>
                <li>Backup and recovery resources</li>
            </ul>
            <h4>Rollout Strategies:</h4>
            <ul>
                <li>Phased implementation</li>
                <li>Fallback planning</li>
                <li>Parallel operation considerations</li>
                <li>Cutover window management</li>
            </ul>
            <h4>Operational Readiness:</h4>
            <ul>
                <li>Backup and recovery procedures</li>
                <li>Monitoring setup</li>
                <li>Maintenance scheduling</li>
                <li>Problem resolution processes</li>
            </ul>

            <h3>Ongoing Database Maintenance</h3>
            <p>Database design implementation is not complete until maintenance processes are established:</p>
            <h4>Routine Maintenance:</h4>
            <ul>
                <li>RUNSTATS frequency</li>
                <li>REORG criteria</li>
                <li>COPY scheduling</li>
                <li>CHECK integrity validation</li>
            </ul>
            <h4>Space Management:</h4>
            <ul>
                <li>Free space monitoring</li>
                <li>Extent management</li>
                <li>Dataset allocation planning</li>
                <li>Storage group monitoring</li>
            </ul>
            <h4>Performance Management:</h4>
            <ul>
                <li>Access path stability</li>
                <li>Index effectiveness monitoring</li>
                <li>Buffer pool tuning</li>
                <li>Partition growth management</li>
            </ul>
            <h4>Schema Evolution Processes:</h4>
            <ul>
                <li>Change request procedures</li>
                <li>Impact assessment methodology</li>
                <li>Testing requirements</li>
                <li>Implementation windows</li>
            </ul>
        </section>

        <section id="conclusion">
            <h2>Conclusion</h2>
            <p>Effective database design and implementation in DB2 for z/OS requires balancing theoretical principles with practical mainframe considerations. A well-designed database provides a foundation for application performance, data integrity, and system maintainability.</p>
            <p>The design process should progress methodically from requirements gathering through conceptual, logical, and physical design stages, with appropriate consideration for the unique characteristics of the mainframe environment and DB2's architecture.</p>
            <p>Implementation should follow established best practices for object creation, constraint definition, and performance optimization, with particular attention to operational aspects such as partitioning, space management, and maintenance procedures.</p>
            <p>By applying these principles and practices, organizations can develop DB2 databases that effectively support business requirements while providing the performance, reliability, and scalability demanded by mission-critical mainframe applications.</p>
        </section>

        <footer>
            <p>Made with passion for mainframes & DB2. &copy; 2025 Tom Deloddere.</p>

            <p>Sources for Chapter 3:
                <a href="https://aws.amazon.com/blogs/database/validate-database-object-consistency-after-migrating-from-ibm-db2-z-os-to-amazon-rds-for-db2/" target="_blank" rel="noopener noreferrer">aws.amazon.com</a>,
                <a href="https://aws.amazon.com/blogs/database/validate-database-objects-after-migrating-from-ibm-db2-z-os-to-amazon-rds-for-postgresql-or-amazon-aurora-postgresql/" target="_blank" rel="noopener noreferrer">aws.amazon.com</a>,
                <a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=databases-implementing-your-database-design" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://stackoverflow.com/questions/3289433/where-to-start-learning-db2-programming" target="_blank" rel="noopener noreferrer">stackoverflow.com</a>,
                <a href="https://virtualusergroups.com/wp-content/uploads/presentations/Virtual%20Db2%20-%20Db2%2012_13%20for%20zOS%20Database%20Design%20and%20Application%20Performance.pdf" target="_blank" rel="noopener noreferrer">virtualusergroups.com</a>,
                <a href="https://www.ibmmainframer.com/db2-tutorial/db2-sql-create-index-statement/" target="_blank" rel="noopener noreferrer">ibmmainframer.com</a>,
                <a href="https://bookshelf.erwin.com/bookshelf/public_html/2020R1/Content/User%20Guides/erwin%20Help/Define_a_DB2_zOS_Index.html" target="_blank" rel="noopener noreferrer">bookshelf.erwin.com</a>,
                <a href="https://techdocs.broadcom.com/us/en/ca-mainframe-software/database-management/ca-rc-migrator-for-db2-for-z-os-and-ca-rc-compare/20-0/using/manage-db2-objects/indexes/index-create-option.html" target="_blank" rel="noopener noreferrer">techdocs.broadcom.com</a>,
                <a href="https://bookshelf.erwin.com/bookshelf/public_html/2020R1/Content/User%20Guides/erwin%20Help/Define_a_DB2_zOS_Auxiliary_Table_Index.html" target="_blank" rel="noopener noreferrer">bookshelf.erwin.com</a>,
                <a href="https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-db2-concepts" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=constraints-referential" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://www.ibmmainframer.com/db2-tutorial/db2-data-integrity/" target="_blank" rel="noopener noreferrer">ibmmainframer.com</a>,
                <a href="https://craigsmullins.com/index_htm_files/Quest%20-%202014-08%20-%20How%20to%20Assure%20Data%20Integrity%20in%20DB2%20for%20zOS.pdf" target="_blank" rel="noopener noreferrer">craigsmullins.com</a>,
                <a href="https://techdocs.broadcom.com/us/en/ca-mainframe-software/database-management/ca-rc-query-for-db2-for-z-os/20-0/reporting/referential-integrity-reports.html" target="_blank" rel="noopener noreferrer">techdocs.broadcom.com</a>
            </p>
        </footer>
    </div>
    <script>
        const backToQuizBtn = document.getElementById('back-to-quiz-btn');
            backToQuizBtn.addEventListener('click', function() {
                window.location.href = '../index.html';
            });
    </script>
</body>
</html>
