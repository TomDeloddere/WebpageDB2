<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <title>DB2 Performance Optimization</title>
    <style>
        button {
          background-color: #001a00; /* Dark green background */
          color: #33ff33; /* Bright green text */
          font-family: 'Courier New', monospace;
          font-weight: bold;
          border: 1px solid #33ff33;
          padding: 8px 15px;
          cursor: pointer;
          transition: all 0.3s;
          text-transform: uppercase;
          letter-spacing: 1px;
          display: flex; /* Align icon and text */
          align-items: center;
      }
      button:hover {
          background-color: rgba(51, 255, 51, 0.2);
          color: #ffffff; /* White text on hover */
          box-shadow: 0 0 8px rgba(51, 255, 51, 0.6);
      }
      button:disabled {
          background-color: #05050a; /* Darker background when disabled */
          color: #447744; /* Dimmed green text */
          border-color: #225522; /* Dimmed border */
          cursor: not-allowed;
          opacity: 0.6;
      }
      button .lucide {
          margin-right: 8px; /* Space before text */
      }
        /* General styles - Mainframe inspired but optimized for learning */
        body {
            background-color: #0a0a14;
            color: #b3ffb3;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            text-shadow: 0 0 2px rgba(179, 255, 179, 0.4);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(10, 10, 20, 0.7);
            border: 1px solid #33ff33;
            box-shadow: 0 0 10px rgba(51, 255, 51, 0.3);
        }
        header {
            background-color: #001a00;
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #33ff33;
            margin-bottom: 30px;
        }
        h1 {
            color: #33ff33;
            font-size: 2.2rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        nav {
            background-color: #001a00;
            padding: 10px 0;
            margin-bottom: 30px;
            border-bottom: 1px solid #33ff33;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        nav li {
            margin: 5px 15px; /* Add vertical margin for wrapped items */
        }
        nav a {
            color: #33ff33;
            text-decoration: none;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 3px;
            transition: all 0.3s;
        }
        nav a:hover {
            background-color: rgba(51, 255, 51, 0.2);
            color: #ffffff;
        }
        section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: rgba(0, 26, 0, 0.3);
            border-left: 3px solid #33ff33;
        }
        h2 {
            color: #00ff99;
            border-bottom: 1px solid #00ff99;
            padding-bottom: 10px;
            font-size: 1.8rem;
        }
        h3 {
            color: #00ffcc;
            font-size: 1.4rem;
            margin-top: 25px;
        }
        h4 { /* Style for h4 */
            color: #00e6b8; /* Slightly different color */
            font-size: 1.2rem;
            margin-top: 20px;
            text-decoration: underline;
        }
        p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        .code-block {
            background-color: #000000;
            border: 1px solid #33ff33;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            color: #33ff33;
            white-space: pre; /* Preserve whitespace and line breaks */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: rgba(0, 0, 0, 0.5);
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #33ff33;
        }
        th {
            background-color: #001a00;
            color: #00ff99;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        tr:hover {
            background-color: rgba(51, 255, 51, 0.1);
        }
        ul, ol {
            padding-left: 25px;
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        .note {
            background-color: rgba(0, 26, 51, 0.5);
            border-left: 4px solid #3399ff;
            padding: 15px;
            margin: 20px 0;
            color: #99ccff;
        }
        .important {
            background-color: rgba(51, 0, 0, 0.5);
            border-left: 4px solid #ff3333;
            padding: 15px;
            margin: 20px 0;
            color: #ffb3b3;
        }
        .terminal {
            background-color: #000000;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            color: #33ff33;
            border: 1px solid #33ff33;
            position: relative;
        }
        .terminal::before {
            content: "z/OS >";
            color: #00ff99;
            font-weight: bold;
            margin-right: 10px;
        }
        .diagram {
            background-color: #000000;
            border: 1px solid #33ff33;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-style: italic;
        }
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #33ff33;
            font-size: 0.9rem;
            color: #66ff66;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            nav ul {
                flex-direction: column;
                align-items: center;
            }
            nav li {
                margin: 5px 0;
            }
            h1 {
                font-size: 1.8rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            h3 {
                font-size: 1.2rem;
            }
            h4 {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DB2 Performance Optimization</h1>
            <button id="back-to-quiz-btn">
                <span class="lucide">&#xe3a7;</span> Back To Mainpage
            </button>
        </header>

        <nav>
             <ul>
                 <li><a href="#intro">Intro</a></li>
                 <li><a href="#tools">Tools</a></li>
                 <li><a href="#runstats">RUNSTATS</a></li>
                 <li><a href="#bottlenecks">Bottlenecks</a></li>
                 <li><a href="#query">Query Opt</a></li>
                 <li><a href="#practices">Practices</a></li>
                 <li><a href="#advanced">Advanced</a></li>
                 <li><a href="#conclusion">Conclusion</a></li>
             </ul>
         </nav>

        <section id="intro">
            <h2>Introduction to Database Performance Management</h2>
            <p>Performance management is a critical discipline for DB2 database administrators, requiring a blend of technical knowledge, analytical skills, and experience. In mainframe environments, where DB2 often supports mission-critical applications with strict service level agreements, performance optimization directly impacts business operations and can yield significant cost savings by reducing CPU consumption and improving response times.</p>
            <p>Effective DB2 performance management involves a comprehensive approach that includes:</p>
            <ul>
                <li><strong>Proactive monitoring:</strong> Continuously tracking database performance metrics to identify trends and potential issues before they impact users.</li>
                <li><strong>Performance analysis:</strong> Using diagnostic tools and techniques to determine the root causes of performance problems.</li>
                <li><strong>Tuning implementation:</strong> Applying appropriate optimization techniques at the database, application, or system level.</li>
                <li><strong>Verification and measurement:</strong> Confirming that performance improvements achieve the desired results.</li>
                <li><strong>Impact assessment:</strong> Understanding how changes in one area might affect performance in others.</li>
            </ul>
            <p>The performance optimization process is cyclical rather than linear, requiring ongoing attention as workloads evolve, data volumes grow, and system configurations change. The goal is to achieve optimal performance while balancing competing factors like resource utilization, response time, throughput, and availability.</p>
        </section>

        <section id="tools">
            <h2>DB2 Performance Monitoring and Analysis Tools</h2>
            <p>DB2 for z/OS provides a rich set of tools and utilities for monitoring and analyzing performance:</p>

            <h3>System-Level Monitoring Tools</h3>
            <h4>DB2 Instrumentation Facility:</h4>
            <ul>
                <li>System-level traces: Statistics, accounting, performance, audit, and monitor traces</li>
                <li>IFCID (Instrumentation Facility Component ID): Specific events or data points that can be traced</li>
                <li>Trace destination options: SMF, GTF, OPn, or RES buffers</li>
            </ul>
            <h4>SMF Records:</h4>
            <ul>
                <li>Type 100 (Statistics): System-wide DB2 statistics</li>
                <li>Type 101 (Accounting): Thread-level accounting information</li>
                <li>Type 102 (Performance): Detailed performance data</li>
                <li>Type 199 (Specialized): Special monitoring data</li>
            </ul>
            <h4>DB2 Commands for Monitoring:</h4>
            <ul>
                <li>DISPLAY THREAD: Shows active connections and their status</li>
                <li>DISPLAY DATABASE: Shows status of database objects</li>
                <li>DISPLAY BUFFERPOOL: Shows buffer pool statistics</li>
                <li>DISPLAY LOCATION: Shows distributed connections</li>
                <li>DISPLAY DDF DETAIL: Shows DDF activity statistics</li>
            </ul>

            <h3>Object-Level Analysis Tools</h3>
            <h4>RUNSTATS Utility:</h4>
            <ul>
                <li>Collects statistics about tables, indexes, and column values</li>
            </ul>
            <h4>EXPLAIN Facility:</h4>
            <ul>
                <li>PLAN_TABLE: Contains access path information</li>
                <li>DSN_STATEMNT_TABLE: Contains statement cost information</li>
                <li>DSN_FUNCTION_TABLE: Contains function resolution information</li>
                <li>DSN_STATEMENT_CACHE_TABLE: Contains dynamic SQL cache information</li>
            </ul>
            <h4>Catalog Tables:</h4>
            <ul>
                <li>SYSIBM.SYSTABLES: Table statistics</li>
                <li>SYSIBM.SYSINDEXES: Index statistics</li>
                <li>SYSIBM.SYSCOLUMNS: Column statistics</li>
                <li>SYSIBM.SYSKEYTARGETS: Key statistics for index expressions</li>
            </ul>
            <h4>DB2 Query Monitor:</h4>
            <ul>
                <li>Real-time monitoring of SQL statement performance</li>
            </ul>

            <h3>Performance Analysis Methodologies</h3>
            <h4>Workload Analysis:</h4>
            <ul>
                <li>Identify top resource consumers (CPU, I/O, elapsed time)</li>
                <li>Categorize by application, authorization ID, or location</li>
                <li>Determine patterns and peak usage periods</li>
                <li>Compare against baseline measurements</li>
            </ul>
            <h4>Problem Determination:</h4>
            <ul>
                <li>Establish scope (system-wide or specific applications)</li>
                <li>Collect relevant diagnostic data</li>
                <li>Analyze symptoms and identify probable causes</li>
                <li>Develop and test potential solutions</li>
                <li>Implement and verify fixes</li>
            </ul>
            <h4>Performance Trending:</h4>
            <ul>
                <li>Collect performance metrics over time</li>
                <li>Establish normal operating patterns</li>
                <li>Identify anomalies and gradual degradation</li>
                <li>Forecast future resource requirements</li>
            </ul>
            <h4>Event Analysis:</h4>
            <ul>
                <li>Identify specific performance incidents</li>
                <li>Correlate with system events or changes</li>
                <li>Analyze environmental factors</li>
                <li>Determine trigger conditions</li>
            </ul>
        </section>

        <section id="runstats">
            <h2>Running RUNSTATS and Interpreting Results</h2>
            <p>The RUNSTATS utility is a cornerstone of DB2 performance optimization, collecting statistical information that the optimizer uses to determine efficient access paths.</p>

            <h3>RUNSTATS Execution Options</h3>
            <h4>Basic RUNSTATS Syntax:</h4>
<pre class="code-block">
RUNSTATS TABLESPACE database-name.tablespace-name
         TABLE(ALL) INDEX(ALL)
         SHRLEVEL REFERENCE
         UPDATE ALL;
</pre>
            <h4>Key Parameters:</h4>
            <ul>
                <li><strong>SHRLEVEL:</strong> Controls level of access during statistics collection
                    <ul>
                        <li>REFERENCE: Read-only access to data</li>
                        <li>CHANGE: Allows concurrent updates</li>
                    </ul>
                </li>
                <li><strong>UPDATE:</strong> Determines where statistics are stored
                    <ul>
                        <li>ALL: Updates both catalog and RTS tables</li>
                        <li>ACCESSPATH: Updates statistics used for access path selection</li>
                        <li>SPACE: Updates space-related statistics</li>
                        <li>NONE: Collects statistics without updating catalogs</li>
                    </ul>
                </li>
                <li><strong>REPORT:</strong> Generates a report without updating statistics</li>
                <li><strong>KEYCARD:</strong> Collects cardinality statistics for index keys</li>
                <li><strong>HISTOGRAM:</strong> Collects frequency statistics for column values</li>
                <li><strong>COLGROUP:</strong> Collects statistics for groups of correlated columns</li>
            </ul>
            <h4>Statistics Collection Strategies:</h4>
            <ul>
                <li><strong>Comprehensive Collection:</strong>
<pre class="code-block">
RUNSTATS TABLESPACE dbname.tsname
         TABLE(ALL) INDEX(ALL)
         SHRLEVEL CHANGE
         UPDATE ALL
         HISTOGRAM NUMQUANTILES 100;
</pre>
                </li>
                <li><strong>Focused Collection:</strong>
<pre class="code-block">
RUNSTATS TABLESPACE dbname.tsname
         TABLE(schema.table)
         COLUMN(col1,col2)
         COLGROUP(col3,col4) FREQVAL COUNT 20
         INDEX(schema.index1,schema.index2)
         SHRLEVEL CHANGE
         UPDATE ALL;
</pre>
                </li>
                <li><strong>Efficient Collection for Large Tables:</strong>
<pre class="code-block">
RUNSTATS TABLESPACE dbname.tsname
         TABLE(schema.table) SAMPLE 25
         INDEX(ALL) SAMPLE 25
         SHRLEVEL CHANGE
         UPDATE ALL;
</pre>
                </li>
            </ul>

            <h3>Interpreting RUNSTATS Results</h3>
            <h4>Key Table Statistics:</h4>
            <ul>
                <li>CARDF: Number of rows in the table</li>
                <li>NPAGES: Number of pages with active rows</li>
                <li>PCTPAGES: Percentage of space used in tablespace</li>
                <li>PCTROWCOMP: Percentage of rows compressed</li>
                <li>AVGROWLEN: Average row length</li>
            </ul>
            <h4>Key Index Statistics:</h4>
            <ul>
                <li>FIRSTKEYCARDF: Number of distinct values in first key column</li>
                <li>FULLKEYCARDF: Number of distinct values for full key</li>
                <li>NLEAF: Number of leaf pages</li>
                <li>NLEVELS: Number of levels in the index</li>
                <li>CLUSTERRATIO: Measure of data clustering according to index</li>
            </ul>
            <h4>Column Statistics:</h4>
            <ul>
                <li>COLCARDF: Number of distinct values in the column</li>
                <li>HIGH2KEY/LOW2KEY: Second-highest/lowest values</li>
                <li>HISTOGRAM statistics: Distribution of values across ranges</li>
            </ul>
            <h4>Analysis of Statistical Data:</h4>
            <ul>
                <li><strong>Cardinality Assessment:</strong>
                    <ul>
                        <li>Low COLCARDF relative to CARDF indicates low uniqueness</li>
                        <li>High COLCARDF close to CARDF indicates high uniqueness</li>
                        <li>Impacts index selection and join strategies</li>
                    </ul>
                </li>
                <li><strong>Clustering Evaluation:</strong>
                    <ul>
                        <li>CLUSTERRATIO near 100 indicates excellent clustering</li>
                        <li>Low values may indicate need for REORG</li>
                        <li>Impacts sequential access efficiency</li>
                    </ul>
                </li>
                <li><strong>Space Utilization:</strong>
                    <ul>
                        <li>Compare NPAGES to theoretical optimal</li>
                        <li>High PCTROWCOMP indicates effective compression</li>
                        <li>Low space utilization may indicate need for REORG</li>
                    </ul>
                </li>
                <li><strong>Index Efficiency:</strong>
                    <ul>
                        <li>NLEVELS > 3 may indicate need for evaluation in large tables</li>
                        <li>LEAFDIST shows distribution of leaf pages</li>
                        <li>Physical design implications based on access patterns</li>
                    </ul>
                </li>
                <li><strong>Histogram Analysis:</strong>
                    <ul>
                        <li>Identifies skewed data distributions</li>
                        <li>Enables better predicate selectivity estimates</li>
                        <li>Helps optimize queries with range conditions</li>
                    </ul>
                </li>
            </ul>

            <h3>Scheduling and Automating RUNSTATS</h3>
            <h4>Scheduling Considerations:</h4>
            <ul>
                <li>After significant data changes (typically 10-20% changes)</li>
                <li>Following major loads or mass updates</li>
                <li>Prior to rebinding applications</li>
                <li>After reorganizations</li>
                <li>On a regular maintenance schedule for critical objects</li>
            </ul>
            <h4>Automation Approaches:</h4>
            <ul>
                <li>Using REORG with inline RUNSTATS</li>
                <li>Implementing threshold-based execution through RTS</li>
                <li>Scheduling through system automation tools</li>
                <li>Using DB2 utilities like DSNACCOX stored procedure</li>
            </ul>
            <h4>Real-Time Statistics Integration:</h4>
            <ul>
                <li>Monitoring TOTALROWS vs. CARDF</li>
                <li>Tracking REORGMODIFIEDPAGES for update activity</li>
                <li>Using STATSTIME to identify outdated statistics</li>
                <li>Implementing automated RUNSTATS based on RTS thresholds</li>
            </ul>
        </section>

        <section id="bottlenecks">
            <h2>Identifying and Resolving Performance Bottlenecks</h2>
            <p>Effective performance problem resolution requires a systematic approach to identify, analyze, and address bottlenecks.</p>

            <h3>Common Performance Bottlenecks</h3>
            <h4>CPU-Related Issues:</h4>
            <ul>
                <li>Inefficient SQL statements consuming excessive CPU</li>
                <li>Lack of appropriate indexes leading to tablespace scans</li>
                <li>Excessive sorting operations</li>
                <li>Unoptimized application code or stored procedures</li>
                <li>Excessive RID list processing</li>
                <li>Suboptimal query parallelism</li>
            </ul>
            <h4>I/O-Related Issues:</h4>
            <ul>
                <li>Buffer pool thrashing (high read/write ratios)</li>
                <li>Synchronous I/O waits</li>
                <li>Inefficient prefetch operations</li>
                <li>Log bottlenecks during heavy update operations</li>
                <li>Contention for I/O subsystem resources</li>
                <li>Poorly organized data requiring excessive I/O</li>
            </ul>
            <h4>Lock-Related Issues:</h4>
            <ul>
                <li>Lock contention between transactions</li>
                <li>Excessive lock wait times</li>
                <li>Deadlocks and timeouts</li>
                <li>Lock escalation impacting concurrency</li>
                <li>Inappropriate isolation levels</li>
                <li>Improper locking strategies in applications</li>
            </ul>
            <h4>Memory-Related Issues:</h4>
            <ul>
                <li>Insufficient buffer pool size</li>
                <li>EDM pool constraints</li>
                <li>RID pool overflows</li>
                <li>Sort pool limitations</li>
                <li>Excessive working storage requirements</li>
                <li>Global shared memory constraints in data sharing</li>
            </ul>
            <h4>Network-Related Issues:</h4>
            <ul>
                <li>Distributed query bottlenecks</li>
                <li>Excessive network traffic due to large result sets</li>
                <li>Connection pooling inefficiencies</li>
                <li>DDF thread limitations</li>
                <li>Network latency impacts on distributed operations</li>
            </ul>

            <h3>Systematic Problem Resolution</h3>
            <h4>Step 1: Identify Symptoms</h4>
            <ul>
                <li>Analyze application response times</li>
                <li>Review DB2 accounting reports for long-running threads</li>
                <li>Examine resource consumption patterns</li>
                <li>Identify specific SQL statements with performance issues</li>
                <li>Check for lock timeouts, deadlocks, or resource constraints</li>
            </ul>
            <h4>Step 2: Collect Diagnostic Data</h4>
            <ul>
                <li>Gather relevant statistics traces</li>
                <li>Run EXPLAIN for problematic SQL</li>
                <li>Review buffer pool and other subsystem statistics</li>
                <li>Analyze lock activity reports</li>
                <li>Examine system logs for error conditions</li>
            </ul>
            <h4>Step 3: Analyze Root Causes</h4>
            <ul>
                <li>Determine if issues are application, database, or system-related</li>
                <li>Identify resource constraints or contention points</li>
                <li>Evaluate access path selection and join strategies</li>
                <li>Check for data skew or statistical anomalies</li>
                <li>Review concurrency and locking behaviors</li>
            </ul>
            <h4>Step 4: Develop Solutions</h4>
            <ul>
                <li>Design appropriate indexing strategies</li>
                <li>Optimize SQL statements</li>
                <li>Adjust DB2 subsystem parameters</li>
                <li>Recommend application changes</li>
                <li>Implement data organization improvements</li>
            </ul>
            <h4>Step 5: Implement and Verify</h4>
            <ul>
                <li>Apply changes in controlled manner</li>
                <li>Measure before and after performance</li>
                <li>Verify problem resolution</li>
                <li>Document changes and outcomes</li>
                <li>Monitor for any secondary effects</li>
            </ul>

            <h3>Case Study Approach to Common Bottlenecks</h3>
            <h4>Case 1: Excessive Tablespace Scans</h4>
            <ul>
                <li>Symptom: High CPU usage, long-running queries</li>
                <li>Diagnosis: EXPLAIN shows TABLESCAN access with high cost</li>
                <li>Solution: Create appropriate indexes based on predicates</li>
                <li>Verification: Reduced CPU time and elapsed time after index creation</li>
            </ul>
            <h4>Case 2: Buffer Pool Contention</h4>
            <ul>
                <li>Symptom: High synchronous read I/O, buffer pool thrashing</li>
                <li>Diagnosis: Low buffer pool hit ratios, high read I/O rates</li>
                <li>Solution: Increase buffer pool size, adjust thresholds, separate workloads</li>
                <li>Verification: Improved hit ratios, reduced I/O wait times</li>
            </ul>
            <h4>Case 3: Lock Contention</h4>
            <ul>
                <li>Symptom: Timeouts, deadlocks, excessive wait times</li>
                <li>Diagnosis: Lock activity reports show contention points</li>
                <li>Solution: Adjust isolation levels, modify application locking strategy</li>
                <li>Verification: Reduced lock wait times, fewer timeouts</li>
            </ul>
            <h4>Case 4: Sort Performance Issues</h4>
            <ul>
                <li>Symptom: High sort activity, spill to workfiles</li>
                <li>Diagnosis: Sort pool statistics show excessive external sorts</li>
                <li>Solution: Increase sort pool size, create indexes to avoid sorts</li>
                <li>Verification: Reduced sort activity, fewer workfile sorts</li>
            </ul>
            <h4>Case 5: Distributed Query Performance</h4>
            <ul>
                <li>Symptom: Slow response for distributed applications</li>
                <li>Diagnosis: High network traffic, excessive result set size</li>
                <li>Solution: Implement result set blocking, reduce data transfer</li>
                <li>Verification: Improved response time, reduced network traffic</li>
            </ul>
        </section>

        <section id="query">
            <h2>Optimizing Query Execution</h2>
            <p>Query optimization involves multiple techniques to improve the efficiency of SQL statement execution.</p>

            <h3>Understanding DB2 Query Optimizer</h3>
            <h4>Optimizer Components:</h4>
            <ul>
                <li>Parser: Checks SQL syntax and semantics</li>
                <li>Query Graph Model (QGM): Internal representation of the query</li>
                <li>Access Path Selection: Determines the execution strategy</li>
                <li>Cost Estimation: Calculates resource requirements</li>
                <li>Plan Generation: Creates executable access plan</li>
            </ul>
            <h4>Optimization Phases:</h4>
            <ul>
                <li>Query rewrite: Transforms SQL into more efficient form</li>
                <li>Access path selection: Chooses tables access methods</li>
                <li>Join sequence determination: Orders table joins efficiently</li>
                <li>Join method selection: Chooses appropriate join techniques</li>
                <li>Parallelism evaluation: Determines parallel execution options</li>
            </ul>
            <h4>Cost-Based Optimization Factors:</h4>
            <ul>
                <li>Statistical information from catalog tables</li>
                <li>Available indexes and their characteristics</li>
                <li>Predicate selectivity estimates</li>
                <li>Resource costs (CPU, I/O, sort work)</li>
                <li>Parameter marker and host variable influences</li>
                <li>Join method efficiency for the specific query</li>
            </ul>

            <h3>Influencing the Optimizer</h3>
            <h4>OPTIMIZE FOR n ROWS:</h4>
            <ul>
                <li>Influences retrieval strategy based on expected result size</li>
                <li>Useful for queries returning small subsets of large tables</li>
<pre class="code-block">
SELECT * FROM LARGE_TABLE
 WHERE REGION = 'EAST'
 OPTIMIZE FOR 100 ROWS;
</pre>
            </ul>
            <h4>FETCH FIRST n ROWS ONLY:</h4>
            <ul>
                <li>Limits result set size</li>
                <li>Can enable optimization techniques like early termination</li>
<pre class="code-block">
SELECT * FROM EMPLOYEE
 ORDER BY SALARY DESC
 FETCH FIRST 10 ROWS ONLY;
</pre>
            </ul>
            <h4>REOPT Clause:</h4>
            <ul>
                <li>REOPT(ALWAYS): Optimizes at execution time using actual values</li>
                <li>REOPT(ONCE): Optimizes on first execution and reuses plan</li>
                <li>REOPT(AUTO): DB2 determines when to reoptimize</li>
<pre class="code-block">
SELECT * FROM CUSTOMER
 WHERE REGION = ?
 WITH REOPT(ALWAYS);
</pre>
            </ul>
            <h4>Optimization Hints:</h4>
            <ul>
                <li>APPEND: Forces append processing for inserts</li>
                <li>CONCENTRATE STATEMENTS: Enables literal concentration</li>
                <li>QUERYNO: Identifies specific queries for optimization</li>
                <li>PACKAGE/COLLECTION: Associates optimization with packages</li>
<pre class="code-block">
SELECT /*+ QUERYNO(100) */ *
 FROM ORDERS
 WHERE STATUS = 'OPEN';
</pre>
            </ul>

            <h3>SQL Query Tuning Techniques</h3>
            <h4>Predicate Optimization:</h4>
            <ul>
                <li>Stage 1 vs. Stage 2 predicates</li>
                <li>Indexable vs. non-indexable predicates</li>
                <li>Predicate order and evaluation efficiency</li>
                <li>Sargable predicate formulation</li>
            </ul>
            <h4>Join Optimization:</h4>
            <ul>
                <li>Nested Loop Join: Efficient for small tables or indexed access</li>
                <li>Merge Scan Join: Effective when data is pre-sorted</li>
                <li>Hybrid Join: Combination approach for specific scenarios</li>
                <li>Star Join: Optimized for star schema queries</li>
            </ul>
            <h4>Subquery Transformation:</h4>
            <ul>
                <li>Subquery-to-join conversion</li>
                <li>IN-list predicate optimization</li>
                <li>Materialization vs. correlation techniques</li>
                <li>EXISTS vs. IN predicate choices</li>
            </ul>
            <h4>Index Design Strategies:</h4>
            <ul>
                <li>Covering indexes to avoid data page access</li>
                <li>Index-only access paths</li>
                <li>Index screening for complex predicates</li>
                <li>Matching index design to query patterns</li>
            </ul>

            <h3>Specific Optimization Techniques</h3>
            <h4>1. Rewriting SQL for Efficiency</h4>
            <ul>
                <li>Original Query:
<pre class="code-block">
SELECT * FROM EMPLOYEE
 WHERE SUBSTR(LASTNAME, 1, 3) = 'SMI';
</pre>
                </li>
                <li>Optimized Query:
<pre class="code-block">
SELECT * FROM EMPLOYEE
 WHERE LASTNAME LIKE 'SMI%';
</pre>
                </li>
            </ul>
            <h4>2. Avoiding Functions on Indexed Columns</h4>
            <ul>
                <li>Original Query:
<pre class="code-block">
SELECT * FROM ORDERS
 WHERE YEAR(ORDER_DATE) = 2024;
</pre>
                </li>
                <li>Optimized Query:
<pre class="code-block">
SELECT * FROM ORDERS
 WHERE ORDER_DATE BETWEEN '2024-01-01' AND '2024-12-31';
</pre>
                </li>
            </ul>
            <h4>3. Using Multi-Index Access</h4>
<pre class="code-block">
CREATE INDEX IX1 ON CUSTOMER(REGION);
CREATE INDEX IX2 ON CUSTOMER(STATUS);

SELECT * FROM CUSTOMER
 WHERE REGION = 'EAST' AND STATUS = 'ACTIVE';
</pre>
            <h4>4. Optimizing IN Lists with OR Predicates</h4>
            <ul>
                <li>Original Query:
<pre class="code-block">
SELECT * FROM PRODUCT
 WHERE CATEGORY = 'A' OR CATEGORY = 'B' OR CATEGORY = 'C';
</pre>
                </li>
                <li>Optimized Query:
<pre class="code-block">
SELECT * FROM PRODUCT
 WHERE CATEGORY IN ('A', 'B', 'C');
</pre>
                </li>
            </ul>
            <h4>5. Using FETCH FIRST for Limited Results</h4>
<pre class="code-block">
SELECT EMPNO, LASTNAME, SALARY
 FROM EMPLOYEE
 ORDER BY SALARY DESC
 FETCH FIRST 10 ROWS ONLY;
</pre>

            <h3>Advanced Optimization Techniques</h3>
            <h4>Parallelism Optimization:</h4>
            <ul>
                <li>I/O Parallelism: Multiple parallel I/O streams</li>
                <li>CPU Parallelism: Parallel processing of query components</li>
                <li>Sysplex Query Parallelism: Cross-system parallel execution</li>
                <li>Controlling parallelism degree with PARAMDEG parameter</li>
            </ul>
            <h4>Materialized Query Tables (MQTs):</h4>
            <ul>
                <li>Pre-computed results for complex queries</li>
                <li>Automatic query rewrites to use MQTs</li>
                <li>Refresh strategies (REFRESH IMMEDIATE vs. DEFERRED)</li>
                <li>System-period temporal tables for historical queries</li>
            </ul>
            <h4>Partition-Level Operations:</h4>
            <ul>
                <li>Partition elimination based on predicates</li>
                <li>Parallel access to multiple partitions</li>
                <li>Pruning strategies for partitioned indexes</li>
                <li>PAGE_RANGE screening for partitioned tables</li>
            </ul>
            <h4>In-Memory Techniques:</h4>
            <ul>
                <li>Buffer pool optimization for critical objects</li>
                <li>PGFIX option for fixed buffer pages</li>
                <li>In-memory data caching strategies</li>
                <li>KEEPALIVE parameters for frequently accessed data</li>
            </ul>
        </section>

        <section id="practices">
            <h2>Performance Tuning Best Practices</h2>
            <p>Effective performance tuning requires a strategic approach that balances immediate fixes with long-term optimization.</p>

            <h3>Systematic Tuning Methodology</h3>
            <h4>1. Establish Performance Baselines</h4>
            <ul>
                <li>Collect comprehensive performance metrics during normal operations</li>
                <li>Document response times, throughput, and resource utilization</li>
                <li>Identify peak workload periods and patterns</li>
                <li>Create baseline reports for future comparison</li>
            </ul>
            <h4>2. Implement Proactive Monitoring</h4>
            <ul>
                <li>Regular review of system performance metrics</li>
                <li>Threshold-based alerting for performance degradation</li>
                <li>Trend analysis to predict future performance issues</li>
                <li>Automated collection of diagnostic information</li>
            </ul>
            <h4>3. Prioritize Tuning Efforts</h4>
            <ul>
                <li>Focus on high-impact, high-visibility applications</li>
                <li>Address system-wide bottlenecks before specific queries</li>
                <li>Target resources with highest utilization or contention</li>
                <li>Weigh effort required against expected performance gain</li>
            </ul>
            <h4>4. Document Changes and Results</h4>
            <ul>
                <li>Maintain detailed records of all performance modifications</li>
                <li>Measure performance metrics before and after changes</li>
                <li>Document unexpected side effects or interactions</li>
                <li>Create knowledge base of effective tuning techniques</li>
            </ul>

            <h3>Preventive Maintenance for Performance</h3>
            <h4>Regular Database Maintenance:</h4>
            <ul>
                <li>Scheduled RUNSTATS to maintain current statistics</li>
                <li>REORG to address physical disorganization</li>
                <li>REBIND of packages to leverage current statistics</li>
                <li>COPY for backup and recovery readiness</li>
            </ul>
            <h4>Capacity Planning:</h4>
            <ul>
                <li>Monitoring growth trends in data volumes</li>
                <li>Forecasting future resource requirements</li>
                <li>Planning for workload increases</li>
                <li>Establishing performance SLAs and objectives</li>
            </ul>
            <h4>Change Management:</h4>
            <ul>
                <li>Performance impact assessment for schema changes</li>
                <li>Query performance regression testing</li>
                <li>Controlled implementation of parameter changes</li>
                <li>Rollback planning for unsuccessful changes</li>
            </ul>

            <h3>Performance Tuning Checklist</h3>
            <h4>Database Design:</h4>
            <ul>
                <li>[ ] Appropriate normalization level for workload type</li>
                <li>[ ] Efficient partitioning strategy for large tables</li>
                <li>[ ] Suitable compression options for data characteristics</li>
                <li>[ ] Strategic use of materialized query tables</li>
                <li>[ ] Optimal data type choices for columns</li>
            </ul>
            <h4>Indexing Strategy:</h4>
            <ul>
                <li>[ ] Index coverage for common query predicates</li>
                <li>[ ] Avoidance of redundant or unused indexes</li>
                <li>[ ] Consideration of index-only access paths</li>
                <li>[ ] Clustering indexes aligned with access patterns</li>
                <li>[ ] Regular review and tuning of index designs</li>
            </ul>
            <h4>Application Design:</h4>
            <ul>
                <li>[ ] Efficient SQL coding practices</li>
                <li>[ ] Appropriate cursor usage and management</li>
                <li>[ ] Batch processing optimization</li>
                <li>[ ] Connection and thread management</li>
                <li>[ ] Proper error handling and recovery</li>
            </ul>
            <h4>System Configuration:</h4>
            <ul>
                <li>[ ] Buffer pool sizing and allocation</li>
                <li>[ ] Sort pool configuration</li>
                <li>[ ] EDM pool sizing</li>
                <li>[ ] RID pool adjustments</li>
                <li>[ ] Thread management parameters</li>
            </ul>
        </section>

        <section id="advanced">
            <h2>Advanced Performance Topics</h2>

            <h3>Performance in Data Sharing Environments</h3>
            <h4>Data Sharing Considerations:</h4>
            <ul>
                <li>Group Buffer Pool (GBP) dependency</li>
                <li>Cross-invalidation overhead</li>
                <li>Coupling Facility resource management</li>
                <li>Global lock management</li>
                <li>XES and XCF communication costs</li>
            </ul>
            <h4>Optimization Techniques:</h4>
            <ul>
                <li>Strategic GBP usage classification</li>
                <li>GBPCACHE settings optimization</li>
                <li>Lock structure sizing and tuning</li>
                <li>CF structure placement and priority</li>
                <li>Member specialization for workload types</li>
            </ul>
            <h4>Monitoring Approaches:</h4>
            <ul>
                <li>GBP dependency and castout statistics</li>
                <li>Global lock contention metrics</li>
                <li>CF response time measurements</li>
                <li>Cross-system queue monitoring</li>
                <li>Write/read ratio optimization</li>
            </ul>

            <h3>Temporal Data Performance</h3>
            <h4>System-Period Temporal Tables:</h4>
            <ul>
                <li>Query optimization with temporal predicates</li>
                <li>History table access strategy</li>
                <li>Partitioning strategies for history tables</li>
                <li>Index design for temporal queries</li>
                <li>BUSINESS_TIME period optimization</li>
            </ul>
            <h4>Tuning Temporal Queries:</h4>
            <ul>
                <li>Effective use of PERIOD specifications</li>
                <li>Partition elimination in historical data</li>
                <li>Optimizing FOR SYSTEM_TIME clauses</li>
                <li>Balancing history retention with performance</li>
                <li>Index strategies for temporal predicates</li>
            </ul>

            <h3>XML and JSON Performance</h3>
            <h4>XML Storage Optimization:</h4>
            <ul>
                <li>XML storage structure considerations</li>
                <li>XML index design and usage patterns</li>
                <li>XML Schema validation performance</li>
                <li>XMLTABLE function optimization</li>
                <li>XPath expression efficiency</li>
            </ul>
            <h4>JSON Performance Techniques:</h4>
            <ul>
                <li>JSON_TABLE function usage</li>
                <li>Storage strategies for JSON documents</li>
                <li>Indexing JSON data</li>
                <li>Query patterns optimization</li>
                <li>Conversion costs management</li>
            </ul>

            <h3>Autonomous Database Features</h3>
            <h4>AI-Enhanced Query Optimization:</h4>
            <ul>
                <li>Machine learning for access path selection</li>
                <li>Adaptive query optimization</li>
                <li>Automated statistics management</li>
                <li>Intelligent buffer pool management</li>
                <li>Workload pattern recognition</li>
            </ul>
            <h4>Automated Performance Management:</h4>
            <ul>
                <li>Self-tuning memory allocation</li>
                <li>Automatic RUNSTATS based on thresholds</li>
                <li>Dynamic parameter adjustment</li>
                <li>Workload-aware resource allocation</li>
                <li>Predictive performance management</li>
            </ul>
        </section>

        <section id="conclusion">
            <h2>Conclusion</h2>
            <p>Performance optimization is both an art and a science, requiring deep technical knowledge, analytical skills, and experience with DB2 in mainframe environments. By mastering the tools and techniques presented in this chapter, database administrators can ensure that DB2 databases deliver optimal performance while efficiently utilizing system resources.</p>
            <p>Effective performance management is not a one-time effort but a continuous process that evolves with changing workloads, growing data volumes, and advancing technology. The methodical approach outlined in this chapter—proactive monitoring, systematic analysis, targeted optimization, and verification of results—provides a framework for maintaining peak performance over time.</p>
            <p>As DB2 continues to evolve with features like artificial intelligence for query optimization, advanced in-memory processing, and enhanced autonomous capabilities, the fundamental principles of performance tuning remain relevant. Understanding the core concepts of relational database performance, mastering the tools for monitoring and analysis, and developing a systematic approach to problem-solving will serve DB2 professionals well in navigating the performance challenges of present and future database environments.</p>
        </section>

        <footer>
            <p>Made with passion for mainframes & DB2. &copy; 2025 Tom Deloddere.</p>

            <p>Sources for Chapter 4:
                <a href="https://www.ibm.com/docs/SSEPEK/pdf/db2z_12_perfbook.pdf" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=utilities-runstats" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://www.idug.org/news/back-to-basics-table-space-scans-for-zos-db2" target="_blank" rel="noopener noreferrer">idug.org</a>,
                <a href="http://www.codug.org/presentations/Db2-RUNSTATS.pdf" target="_blank" rel="noopener noreferrer">codug.org</a>,
                <a href="https://www.protechtraining.com/blog/db2-performance-tuning" target="_blank" rel="noopener noreferrer">protechtraining.com</a>,
                <a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=performance-writing-efficient-sql-queries" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://db2-sql-cookbook.org/" target="_blank" rel="noopener noreferrer">db2-sql-cookbook.org</a>,
                <a href="https://www.amazon.com/DB2-SQL-Tuning-Tips-Developers-ebook/dp/B009R6O2DE" target="_blank" rel="noopener noreferrer">amazon.com</a>,
                <a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=management-ways-improve-query-performance" target="_blank" rel="noopener noreferrer">ibm.com</a>,
                <a href="https://stackoverflow.com/questions/25364801/db2-query-optimization-like-alternative" target="_blank" rel="noopener noreferrer">stackoverflow.com</a>
            </p>
        </footer>
    </div>
    <script>
        const backToQuizBtn = document.getElementById('back-to-quiz-btn');
            backToQuizBtn.addEventListener('click', function() {
                window.location.href = '../index.html';
            });
    </script>
</body>
</html>
